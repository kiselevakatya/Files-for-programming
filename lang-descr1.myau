%scaner_name Lexer
%codes_type lexem_code
%ident_name Id
%token_fields
"usigned __int128 int_val; __float128 float_val;"
%class_members
"unsigned __int128 int_part; __float128 frac_part; ssize_t power; ssize_t sign"
%codes

String, If, Float,
Else, Var, Int,
Bool, Char, Void,
Array, True, False,
Proto, Func, Const,
Elif, Endif, For,
In, While, Repeat,
Until, Exit, Continue,
Return, Read, Print,
Kw_var,Kw_string,Kw_float,
Kw_int,Kw_char, Kw_void,
Kw_bool,

Equal, Plus, Minus,
Mul, Div, Mod,
LT, GT, LEQ,
GEQ, Nequal, FDiv,
Lor, LNor, LNot,
LAnd, LNand, LXor,
LNXor, BXor, BNXor,
BXor, BNXor, BAnd,
BNAnd, LShift, RShift,
BNot, Pow, FPow,
Assign, endif_block, begin_block,
cond_op, after_label,elem_mass,
end_expr, enum, hesh,
toch2

%idents {[:Letter:]|[:letter:]|_}{[:Letter:]|[:letter:]|_|[:digits:]}
%keywords
"если" : If, "еще" : Else, "инес" : Kw_int, "то": Kw_var, "иначе" : Kw_float,"все": Kw_bool,
"ид" : Kw_char, "завершение" :Kw_string,
"для ид" : Kw_void, "завершение" : Array, "правда": True, "ложь": False,"пока": Proto,
"повторяй": Func, "одинаково": Const, "для из": Elif, "и если": Endif,"для": For,
"в": In,"пока": While, "повтор": Repeat, "покуда": Until, "выйди": Exit,
"продолжи": Continue, "вывод": Return, "возврат": Read, "ввод":Print

%delimiters
"=" : Equal, "+" : Plus, "-" : Minus, "*" : Mul, "/" : Div, "%": Mod,
"<": LT, ">":GT, "<=": LEQ, ">=":GEQ, "!=":Nequal,"/.": FPiv, "||": Lor,
"!||": LNor, "!":LNot, "&&": LAnd, "!&&": LNAnd, "^^": LXor,
"!^^": LNXor,"^":BXor,"~^":BNXor,"|":Bor, "~|":BNor,
 "&":BAnd, "~&":BNAnd, "«":LSnift,"»":RSnift,"~":BNot, "**":Pow, "**.":FPow,":=":Assing, "{}":endif_block, "()":begin_block, "#":hesh, "?":cond_op,";":end_expr, ",":enum, "::":after_label,"[]":elem_mass,":":toch2

%strings{"([:ndq:]$write|""$write)*"}


%numbers "val_ = 0; token.code = Number;" : "token.int_val = val_;"
%action addHexDigit "val_ = (val_ « 4) + digitToInt(ch);"
%action addDecDigit "val_ = val_ * 10 + digitToInt(ch);"
%action addBinDigit "val_ = (val_ « 1) + digitToInt(ch);"
%action addOctDigit "val_ = (val_ « 3) + digitToInt(ch);"

{0(x|X)[:xdigits:]$addHexDigit+ | [:digits:]$addDecDigit+ |
0(b|B)[:bdigits:]$addBinDigit+ | 0(o|O)[:odigits:]$addOctDigit+}
