%scaner_name Lexer
%codes_type lexem_code
%ident_name Id
%token_fields
"usigned __int128 int_val; __float128 float_val;"
%class_members
"unsigned __int128 int_part; __float128 frac_part; ssize_t power; ssize_t sign"
%codes

String, If, Float,
Else, Var, Int,
Bool, Char, Void,
Array, True, False,
Proto, Func, Const,
Elif, Endif, For,
In, While, Repeat,
Until, Exit, Continue,
Return, Read, Print,
Kw_var,Kw_string,Kw_float,
Kw_int,Kw_char, Kw_void,
Kw_bool,

Equal, Plus, Minus,
Mul, Div, Mod,
LT, GT, LEQ,
GEQ, Nequal, FDiv,
Lor, LNor, LNot,
LAnd, LNand, LXor,
LNXor, BXor, BNXor,
BXor, BNXor, BAnd,
BNAnd, LShift, RShift,
BNot, Pow, FPow,
Assign, endif_block, begin_block,
cond_op, after_label,elem_mass,
end_expr, enum, hesh,
toch2

%idents {[:Letter:]|[:letter:]|_}{[:Letter:]|[:letter:]|_|[:digits:]}
%keywords
"если" : If, "иначе" : Else, "цел" : Kw_int, "перем" : Var, "вещ" : Kw_float,"лог" : Kw_bool,
"симв" : Kw_char, "строка" : Kw_string, "ничто" : Kw_void, "массив" : Array, "истина": True,
"ложь" : False,"прото" : Proto, "функ" : Func, "конст" : Const, "то" : To, "инес" : Elif, "всё" : Endif,
"для" : For, "из" : In,"пока" : While, "повторяй" : Repeat, "покуда" : Until, "выйди" : Exit,
"продолжи" : Continue, "возврат" : Return, "ввод" : Read, "вывод" : Print

%delimiters
"=" : Equal, "+" : Plus, "-" : Minus, "*" : Mul, "/" : Div, "%": Mod,
"<": LT, ">":GT, "<=": LEQ, ">=":GEQ, "!=":Nequal,"/.": FPiv, "||": Lor,
"!||": LNor, "!":LNot, "&&": LAnd, "!&&": LNAnd, "^^": LXor,
"!^^": LNXor,"^":BXor,"~^":BNXor,"|":Bor, "~|":BNor,
 "&":BAnd, "~&":BNAnd, "«":LSnift,"»":RSnift,"~":BNot, "**":Pow, "**.":FPow,":=":Assing, "{}":endif_block, "()":begin_block, "#":hesh, "?":cond_op,";":end_expr, ",":enum, "::":after_label,"[]":elem_mass,":":toch2

%strings{"([:ndq:]$write|""$write)*"}
%strings "buffer.clean();":"token.code=(buffer.length()==1)?Char:String;"
{"([:ndg:]|"")*"}
{"([:ndq:]$write|""$write)*"}   

% numbers "int_part = 0; frac_part = 1; token.code = Number;" : "token.int_val = int_part;"

  % action addDecDigit "frac_part = frac_part * 10 + digit2int (ch)"
  % action addHexDigit "int_part = (int_part << 4) + digitToInt (ch);"
  % action addDecDigit "int_part = int_part * 10 + digitToInt (ch);"
  % action addBinDigit "int_part = (int_part << 1) + digitToInt (ch);"
  % action addOctDigit "int_part = (int_part << 3) + digitToInt (ch);"
  {0 (x | X) [: xdigits:] $ addHexDigit + | [: цифры:] $ addDecDigit + | 0 (b | B) [: bdigits:] $ addBinDigit + | 0 (o | O) [: odigits:] $ addOctDigit +} |
{[: цифры:] ([цифры:]?) * ([: цифры:].? + ((E | е) (+ | -) [: цифры] +)?)}
 
